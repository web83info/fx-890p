# DisAssembler FX

## はじめに

アセンブラのニーモニックはやっと覚えたんだけど、命令の組み合わせ方が分からないのでプログラムが組めないよう、という方や、パソコンを持ってなくて（あるいはマックのファンで）パソコンのディスアセンブラが使えないよう、という方に最適です。また、最近のPJにソースリストが掲載されないので、困っているという方などです。16進数の羅列を見ても、何も分かりませんからね。例外もいますが。他人のプログラムから、マシン語プログラムの作り方や、プログラムのテクニックを盗みましょう。

## 特徴

以下、[MENU]→[5]で呼び出されるアセンブラを「内蔵アセンブラ」と呼びます。内蔵アセンブラではアセンブルできない命令を含め、（私の知る範囲内での）全80186命令に対応しています。例えば、

```
SHL AX,3
MOV [BX+1234H],CX	
CMP [DI-01H],0DH
```	

などがあります。実際、上に挙げた命令はよく使うんですが、なぜか内蔵アセンブラでは対応されていないんですね。

## 下準備

このプログラム単体では、ROMを解析するくらいしか使いみちがありません。それも十分便利ですが、やはり一番良いのは、PJ読者の皆さんが作ったプログラムを解析することでしょう。

このプログラムは、プログラムがメモリ上のどこかに存在すれば（FD上は不可）、どこの番地に対しても、ディスアセンブルができます。また、ディスアセンブルの結果は、ファイルエリア上、またはFD上に記録することになります。それは、リスト中の140行、変数```K```の値によって変わります。

ファイルエリアに記録するときは、F9をNEWしておいてください。これは、180行の```"F9"```を任意の値にすることにより変更できます。

FDに記録するときは、FDDにアクセスできる状態にしておいてください。ファイル名は```$DISASM.LST```となります。180行にファイル名が指定されていますので、変更したい方はここを書き換えてください。

## 使ってみましょう

それでは、実際に練習してみましょう。これからやることは、練習ですので、やり方を覚えたらそれで結構です。まず、

```
CLEAR 4096,5,6144
MON
E2000
B410CD41CF
Q
```

と入力してください。今、メモリの2000H～2004Hに、あるプログラムがかかれました。早速これをディスアセンブルしてみましょう。

プログラムを実行すると、タイトルが表示されます。最初に、開始アドレスを聞いてきます。デフォルト（=02000H）のままでいいので、そのまま[RET]を押してください。次に終了アドレスを聞いてきます。デフォルトはマシン語エリア終了アドレス（=02004H）です。そのままでいいので、[RET]を押してください。すると、ディスアセンブルを開始します。画面上にはリアルタイムで、現在処理中のアドレスと、ディスアセンブルした結果が表示されていきます。プログラムが終了したら、[MENU]→[1]として、F9を覗いてみてください。次のような結果が得られたでしょうか（ヘッダーとアドレスは省略します）。

```
MOV AH,10H
INT 41H
IRET
```

確かに、正しくディスアセンブルされていますね。ちなみに今、

```
DEFSEG=0
CALL &H2000
```

とすると、画面が消えたとおもいます。これは画面消去のBIOSを呼び出しています。

## 注意

バックスクロールさせながらリアルタイムにディスアセンブルして、解析したりすることはできません。パソコン通信で言うlogをとって、それを参照するようなかたちになっています。更にいうならば、ちょっとディスアセンブル速度が遅いですが、それは仕様です。

## 技術ネタ

番地は、絶対番地形式に直します。条件ジャンプ命令などでは、相対距離の情報が格納されているわけですが（一部命令を除く）、絶対番地形式に計算しなおします。これは「仕様」です。なぜそんなことをするのかといえば、検索機能で簡単にジャンプ先を探せるようにしたかったからです。

また、いわゆる「自動ラベル付加機能」はありませんので、全くソースリストと同じものができるわけではありません。さらに、前後関係から、文字列を探すといったことはできません。つまり、ディスアセンブルリストをもう一回アセンブルすることはできません。

さらに、どうしてもディスアセンブルができないデータは、DB擬似命令を使って処理します。これには、```0FH```（この位置は、オペコード表では```POP CS```にあたるが実際にはない）、```64H```（386以上のCPUでは、```FS:```にあたる）などがあります。

また、どんなデータでもディスアセンブルします。ソースリスト上では、DB擬似命令を使用して文字列のアスキーコードを書き込んだとします。しかし、そのアスキーコード群の最後が、2バイト以上続く命令にディスアセンブルされてしまったらどうすればよいでしょうか。オペコードとオペランドの関係が狂ってしまうので、続く数バイトが変にディスアセンブルされる可能性があります。

例をあげましょう。

```
90              NOP
41        A:    DB    'A'
B8 34 12  B:    MOV   AX,1234H
```

このようなソースリストをアセンブルしてディスアセンブルしたとします。ディスアセンブルすると次のようになるはずです。

```
NOP
ADC   AL,0B8H
XOR   AL,012H
```

ディスアセンブル前とディスアセンブル後で、結果が異なりましたね。このように、DB擬似命令を使う場合は注意してください。この問題を回避するための方法は幾つか考えられますが、部分部分に分けてディスアセンブルするか、または、おかしいと思う部分を自分でディスアセンブルするのがいいと思います。

## 掲載誌

工学社：「Computer fan SPECIAL [2]」 P96, 97