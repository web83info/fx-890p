# LINES-5

SHARP系のポケコンには、6行表示が可能な素晴らしい機種「PC-G850/G830/G820」があります。6行もあれば、さぞRPGやSLG、その他のゲームの制作がやりやすいことでしょう。広い画面は、みんなの長年の希望でしたし。早く市販機がでないかな。

まあ、そんなこんな言っていても始まりません。ポケコン数多しといえども、16ビットCPUを搭載しているのは、CASIOのFX-890P,Z-1,Z-1GR（以下Z-1と略します）のみであります。こうなったら、この高速性を生かして、ソフトで多行表示（もちろん文字は小さくなりますが）できれば、なにかと便利です。

PC-E500系（以下E500と略します）には,PJ '94/3で紹介されているように、5Linesというプログラムが発表されております。それはとても便利なものと見受けられます。

過去のPJを読みあさって、同種のプログラムが、少なくとも私の知る範囲ではZ-1で発表されていないことを確認し、このプログラム開発を開始しました。

Z-1はVRAMの構造上、5行表示が簡単です（後述）。BASICから簡単に使えるようなマシン語サブルーチンを制作しましたので、是非是非使ってみることをおすすめいたします。

## 対応機種

CASIOのFX-890Pで制作しました。ただし、このプログラムはROMの内容を（半）直接CALLしているので、Z-1では動くと思いますが、Z-1GRでは動くかどうかちょいと分かりません。もし、動作確認が取れたら、PJプラザで教えてください。

（半）直接といったのは、アドレスは指定していないが、内部ルーチンを番号指定して呼び出しているという意味です。変数解析や、文字列処理などはROM内部のルーチンで処理させています。ただし、エラー発生ルーチンは、直接アドレスを指定しています。


## 入力方法

プログラムはマシン語で組まれています。まずはマシン語エリアを確保します。BASICかCALモードで、

```
CLEAR 1024,3844,6144
```

と入力します。もし、エラーが出るようだったら、いらないファイルをNEWするなどしてメモリを空けてください。RAMを増設するという手もありますがね。

次に、リスト1を入力します。見かけはBASICプログラムですが、自作のMTOOLを使ってBASICプログラムにコンバ－トされているので、中身はマシン語プログラムです。DEFSEG,POKEに注意してくださいね。
すべて入力し終わったら、必ず外部記憶装置に保存しましょう。そうしたら、

```
RUN
```

と入力して、マシン語プログラムを書き込みます。エラーが出たらその行を修正して、

```
COMPLETED END!
```

と表示されるまで頑張ります。そうしたら2000Hから28FFHまでを外部記憶装置に保存しましょう。保存する方法は、ＦＤＤなら、

```
DEFSEG=0
BSAVE"0:LINES5.BIN",&H2000,&H900
```

となります。これでこのツ－ルの使用が可能となります。

ちなみにリスト1は普通のチェックサムの計算方法と違うので、モニタでは打ち込めません。正確に言うと打ち込めないことはありませんが、チェックサムは当てにはなりません。ご了承ください。また、FX-BCSでのチェックサムを付けましたのでご利用ください（リスト2）。おまけに、ソースリストも公開します（リスト3）。

余談になりますが、この方法（MTOOL方法）のチェックサムに対応したモニタの制作を考えています。

## クイック・リファレンス

```
CALL&H2000,FORMAT
X=1:Y=2:CALL&H2000,X,Y,"I like",REV," PJ ",NORM,"very much."
```

勘のいい方は、これだけでほとんどの使い方をマスターできたと思います。


## 使い方いかに

ROMをコピーして、命令を自作して…と「活研」にやり方は掲載されてはいますが、BASIC命令自体を拡張するのは、E500と比べて敷居が高く、初心者と貧乏人にはまたぎにくいものです。ここでは、CALL文を拡張して、引数（ヒキスウ）をやり取りしています。この方法は結構簡単です。まず、

```
CALL&H2000,FORMAT
```

をプログラムの先頭で実行します。別に先頭でなくても構いませんが、早めにやる方が利口です。これはフォントを初期化します。

表示部の基本的な書式を以下に示します。

```
CALL&H2000,［Ｘ座標］,［Ｙ座標］,データ,データ,...[;]
```

順番に説明します。
コールアドレスは2000H番地です。残念ながらリロケータブル（メモリ内のどの番地にでも配置可能なプログラムのこと）ではありません。呼び出すときは、呼び出す番地を変数に代入しておいて変数を使ってCALLしても大丈夫です。つまり、

```
A=&H2000:CALL A,0,0,"A"
```

などとしてかまいません。

X座標指定値ははLOCATEと同じ形式です。Y座標は0から4までで指定してください。それぞれは変数指定が可能ですが、小数は整数評価されます。それぞれ省略可能ですが、省略したときは以前の表示が終わり、然るべき改行処理がなされたところから表示されます。ただし、省略するときは、カンマは残してください。

```
例：
A=0:CALL &H2000,,A+1,"ABCP"
B=16:CALL &H2000,SQR(B),1,"FX-890P ","Z-1"
```

ただし、ここで難しいのは仮想画面の存在です。このY座標指定は「現在表示されている画面の左上を(0,0)」とします。仮想画面の何行目を表示していても、現在表示されているところを基準に考えます。つまり、例えば、

```
LOCATE0,4:CALL &H2000,0,0,"A"
```

とすると、Aは仮想画面の5行目付近に描かれます。「スクロール処理はしない」ということなので、このような仕様になっているのです。

画面の一番上と一番下は無視されます。ですから、実際に使用しているのは縦30ドットだけです。

その後に続くデータですが、これは例えば以下の形で指定が可能です。

```
例：
CALL &H2000,0,0,A$
CALL &H2000,0,0,MID$(A$,2,2),RIGHT$(A$,1)
CALL &H2000,0,0,REV,A$,NORM,B;
```

データには文字変数も数値変数も使えます。データの区切りはカンマです。セミコロンは不可ですので注意してください。また、データにREV,NORMとありますが、これはPRINT文で使うのとまったく同じです。データの反転処理は、NORM指定されるまで効力が続きますが、次の文になると、反転フラグはリセットされます。

最後にセミコロンをつければ、改行処理を行いません。ここで言う改行処理とは、独自に定めたカーソルポインタの移動のことでスクロールはしません。

USINGには対応しておりません。座標だけ指定したときは、カーソルの改行処理を行いません。当たり前といえば、当たり前なのですが。CLSなどの命令を使って画面を消去しても、カーソルポインタは変化しません。あくまでカーソルポインタはROMとは独立しています。

表示データが長すぎるときなどは、画面外にはみ出してしまうデータを破棄します。文字列の途中でデータが切れてしまうような場合でも、スクロール処理は行いませんので、注意してください。

## フォント書き換え

このプログラムの使用時においては、CHR$(0)からCHR$(31)の制御文字は全く機能しません。これはバージョンアップさせてもこの仕様にしようと思いますが、そのフォント領域（6x32）を利用して、フォント書き換えに対応させました。フォント書き換え自体は、すべての文字に可能です。フォントは全部0から自作したのですが、多少潰れている文字も存在してしまいました。その様な文字で気に入らないものがあったら、書き換えてください。

```
CALL&H2000,FORMAT
```

を実行すると、あるワークエリアにフォントデータがコピーされます。カーソルポインタも初期値に戻ります。フォントデータのコピーされたワークエリアに対して、データを書き換えればOKです。POKE文で書き換えると簡単なのですが、初心者には辛いかもしれないので、専用のコマンドを拡張した次第です。バージョンアップした時、BASICプログラムは無変更で動くように、必ず専用のコマンドを使ってください。

```
CALL&H2000,SET,［番号］,［データ］
```

番号には0から255の数字を指定します。変数評価の方法は、前出の方法と同じです。データの形式は、ROMのデータと同じ形式です。
使用可能な文字は、0,1,2,3,4,5,6,7,8,9,A,B,C,D,E,F,a,b,c,d,e,fです。データ長は12文字、足りない分は自動的に0が補われますし、多い分は無視されます。使用不可の文字が混じっていた場合にはエラーが発生します。ただし、奇数番目の上位2ビットは無視されます。もちろん文字変数の指定も可能です。
データの指定ですが、式などで指定するときは、強引に一つの式で表してください。つまり、

```
1. CALL&H2000,SET,1,"0123"+"4567"
2. CALL&H2000,SET,1,"0123","4567"
3. CALL&H2000,SET,1,"0123";"4567"
```

1はOKですが、2, 3はダメです。

## フォントの作り方

肝心のフォントデータの作り方のお時間です。一度しか説明しないので、お聞き逃しのないように。
まずは、玄人向きの説明です。データは、縦1x横6を1単位（1バイト）とし、6バイトで構成されています。左が上位ビットで、上から下に6バイト重ねます。上位2ビットは無効です。簡単にいえば、ROMフォントと同じ形式です。

初心者の方に説明します。まず、方眼紙をご用意ください。ない方は、適当な紙に6x6のマスを描いてください。そのマスに、好きな絵を描きます。くれぐれもはみ出さないように。私はこんな絵を描きました（図1）。

```
図1 私の描いた絵

■■■■■■
■□□□■■
■□□■□■
■□■□□■
■■□□□■
■■■■■■
```

これを縦1x横6の6つに区切ってください。上から順に1, 2, 3, 4, 5, 6と番号を付けましょう（図２）。

```
図2 番号の付け方

■■■■■■ １
■□□□■■ ２
■□□■□■ ３
■□■□□■ ４
■■□□□■ ５
■■■■■■ ６
```

では、ここから6回のループに入ります。区切られたデータを番号順に取り出して左から1つずつ見ていって、点灯していれば1、点灯していなければ0として、2進数とします。その2進数を16進数に直したものがデータ2つ分です。これを6回繰り返すと、データは完成するのです（図３）。
2進数を16進数にするやり方ですが、初心者は一度、10進数を経由したほうがやりやすいかもしれません。図3を参考にしてください。

```
図3 データの作り方

1番目の場合: 111111(2)
		HEX$(32+16+8+4+2+1)=3F

2番目の場合: 100011(2)
		HEX$(32+2+1)=23

3番目の場合: 100101(2)
		HEX$(32+4+1)=25

以下同様にすると、3F232529313Fというデータができる。
```

慣れてくると、こんなことしなくても見た瞬間にデータが作れるようになります。約束はしませんが、私もフォントエディタを作る前に慣れてしまいましたから。

DEFCHR$では、この5行表示のフォントを書き換えることはできません。またフォントを書き換えても、4行表示のフォントにはまったく影響しません。当たり前です。4行表示のフォントが書き換えられるならやってみたい。

## エラー処理

きちんとエラー処理をしています。エラーメッセージ表示してるけど、実はERR,ERLにエラー番号が返ってこないといったような生ぬるい処理はしていません。BASICとリンクさせて使うのが目的ですから、当然なのですが。以下のエラーが発生する可能性があります。

### エラー１：SN error

理由：文法が間違っている。例えば、文字列指定するときに、かっこが足りないとか、カンマの数がおかしい、FORMATの後に存在しないオプションを付けたなど。LINES-5以前の問題であるという可能性もあり。

対策：正しく直す。マニュアルを良く読むか、PJの掲載リストを穴が開くまでよく見直す。穴が開いて困る人はコピーしよう（そんな人いないって）。

### エラー２：TM error

理由：数字を指定すべき領域に文字列を使った。または、その逆の指定をした。

対策：数値を指定するときに文字変数は使わない。文字変数に計算結果が入っているという場合は、VALまたはVALFを使えば、このエラーは起きない。ただし、数値にならない文字列の場合、0になってしまうので要注意である。
ちなみに、VALの中で16進数を10進数に直したいときは"&H"を使うと便利である。

### エラー３：BS error

理由：どうしてもBack Space Errorと読んで（呼んで）しまうこのエラー。X座標において31以上の数、またY座標において4以上の数を指定した場合、または、どちらか、あるいは両方の値が負の数になってしまったときに発生する。
さらに、フォント書き換え時の2番目のパラメータが255以上の時も発生する。
余談だが、マシン語でマイナスの数は必ず最上位ビットが立っているので、エラーチェックするときは一つのCMP文で済んでしまうので非常にお得である。つまり、後半の例では、

```
CMP DX,255
```

だけで、2つのチェックができる。

対策：範囲外の数を指定しない。以上。
小数は、切り捨てられて整数評価されるから、わざわざINTを使う必要はない。

### エラー４：DA error

理由：フォント定義の際、無効な文字を使用した。ただし、最初の12文字以外の範囲にこれら以外の文字があるときはエラーは発生しない。また、アルファベットは小文字にも対応するので、安心である。

対策：指定された文字以外は使用しない。文字列の中身をよく確認する。0とO,1とIなど打ち間違いはないか。

## 技術情報

CALL文を拡張する方法について簡単に説明します。

CALL文が実行されたとき、ES:[DI]はBASICの中間コードが格納されているアドレスを指しています。そこから、命令やデータなど、必要なものを読み取ってやります。変数処理は少々面倒ですが、変数を使わないようにすれば、本当に簡単です。

ただし、注意しなければならないのは、戻るときそのポインタを書き換えなければなりません。そうしないと、SN errorが発生してしまいます。では、どうすればよいでしょうか。

データを読み込むたびに、SIを更新していけば、戻りポインタの値は計算できます。ただし、ESは固定です。セグメント固定だから、BASICプログラムのサイズは約64キロバイトが限界なんですね。ところで、CALL文を実行したときの様子を活研から調べてみましょう（P100）。まず実行される重要な命令を挙げます。

```
	PUSH DS
	PUSH ES
	PUSH SI
	INT  40H
	ここでマシン語プログラムが処理される
	マシン語プログラムでIRET
	POP  SI
	POP  ES
	POP  DS
```

なんでBASICに戻るときにIRETなのかな、と思っていた方も疑問解決でしょう。CALL文を実行すると、レジスタが保存され、ソフトウェア割り込みを発生させるから、割り込みからのリターン命令であるIRETが使われるのです。

ところで、INT40Hが実行された時点で、スタックには次のようなレジスタが積まれています。

```
	SP→  IRETで戻るOFFSET,SEGMENT,フラグ(6byte)
		SI(2byte)
		ES(2byte)
		DS(2byte)
```

言うまでもありませんが、スタックは下から上に使われるんです。つまり、これ以上スタックに何も積まなければ、WORD PTR [SP+6]にSIの内容が積まれています。ここを書き換えてやればOKです。

## VRAMの仕組み

Z-1のVRAMはPC-E500のそれと構造がかなり異なります。前者は、1バイトで縦1x横6ドット、後者は、1バイトで縦8x横1です。前者は、上位2ビットが無駄といえば無駄なのですが、5行表示プログラムは前者の方が作りやすいのです。なぜでしょうか。後者は、データのマスク処理をしなければなりませんが、前者ではその必要がありません。おかげで、PRINT文使用時より速くなっています。

このプログラムはLCDCを直接いじって描いているので、処理速度がかなり高速かとおもいます。

## 頑張ってね

このプログラムがあるからには、ぜひ誰か5行表示でなければできないゲームなどを作ってください。そうしないと、宝(であることを願う)の持ち腐れになってしまいますから。もちろんこのプログラムは、マシン語が使えない方でも使えるようにできています。個人的には、RPGやSLGなどがやりたいな。

真面目なほうに視点を向けると、…思い付きません。すみません。

まあ、バージョンアップするとしたら、VASS2(VERTEBRA氏)の表示関連ルーチンのように、グラフィック表示(GPRINT相当)とか、さらに回転、反転機能(この場合鏡文字のことです)なんかも面白そうだな。

ゲームを作るのにどうしてもこんな機能が欲しいとか、バグレポートなど、ご意見のある方は、PJプラザ&クラブまでどうぞ。あと、だれかこのプログラムに対応した平仮名フォントとROMに内蔵されている海外フォントを作ってください。かなり難しいかもしれないけれどよろしくお願いします。

余談ですが、「PC-G850」にこのようなプログラムを移植すると、8行表示が可能になります。

## Special Thanks

VERTEBRAの「VASS2」を参考させていただきました。ありがとうございました。
ちなみに、このプログラムは、よく私のプラザに出てくるF君との合作です。いつも迷惑かけてごめんね。でも、プログラムは全部私がやりました。

## 意見文

一つだけ皆さんにお聞きしたいことがあります。「FX-BCS」などのツールがこれから発展してくることと思います。命令の省略をするのとしないのとでは、チェックサムの値は変わってしまいます。例えば、FOR-NEXTの対応が一対一であるなど、ある程度の条件を満たしていれば省略しても差し支えないと私は思うのですが、皆さんはどう考えるでしょうか。
解析する人の身になったご意見を承りたいものです。

## 参考文献

* 工学社：Z-1/FX-890P活用研究
* VERTEBRA氏：VASS2、PJ'95/6 P4~12
* 知研出版株式会社:高等学校 新数学Ⅱ、P140(ギリシャ文字の読み方)
